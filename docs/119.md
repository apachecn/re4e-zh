# 第 11 部分-指针

> 原文：<https://0xinfection.github.io/reversing/pages/part-11-pointers.html>

如需所有课程的完整目录，请点击下方，因为除了课程涵盖的主题之外，它还会为您提供每个课程的简介。[https://github . com/mytechnotalent/逆向工程-教程](https://github.com/mytechnotalent/Reverse-Engineering-Tutorial)

x64 使用平面内存模型，我们在处理器中有一个大的地址数组。

指针只不过是内存中特定值的地址。让我们举个例子:

**mov rax，0x10**

在本例中，我们将 10 个十六进制数移入 **rax** 寄存器。

要在 **0x10，**处获取 **rax** 内的值，您可以使用以下语法:

**mov rbx，字 ptr [rax]**

让我们假设内存 **0x10** 中的值是 **0x20** ，因此 **rax** 指向 **0x10** 中的值，当你通过**【rax】**解引用时，该值包含 **0x20** 。 **0x20** 是寄存器 **rax** 内的值。

我们正在将指向 **rax** 内部的一个字值移动到 **rbx** 中。

如果我们这样做:

**mov 字 ptr [rax]，0x66**

这将把 **0x66** 的值放入 **0x10** 的存储位置。我们知道在 **0x10** 内存位置内的值是 **0x20** ，因此在 **0x10** 内存内的新值将是 **0x66。**

这可能会变得令人困惑，但是当我们在接下来的几个月进入代码时，这将变得更加明显。

下周我们将深入研究负载有效地址！敬请期待！