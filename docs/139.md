# 第 31 部分- x64 组件[第 5 部分]

> 原文:[https://0x infection . github . io/reversing/pages/part-31-x64-assembly-part-5 . html](https://0xinfection.github.io/reversing/pages/part-31-x64-assembly-part-5.html)

如需所有课程的完整目录，请点击下方，因为除了课程涵盖的主题之外，它还会为您提供每个课程的简介。[https://github . com/mytechnotalent/逆向工程-教程](https://github.com/mytechnotalent/Reverse-Engineering-Tutorial)

这个讲座会比大多数讲座长一点，但重要的是你们都花时间真正编码和练习下面讨论的主题。让我们回顾一下我们的代码:

![](../Images/6633c221d519f8948b168c1fc271537d.png)

让我们编译并运行:

![](../Images/1ec08b282251d8fe1d68a00914497641.png)

从上周我们可以看到，我们成功地创建了简单的“Hello World”程序。

在之前的课程中，我提到了 x64 寄存器集，但我将使用此表再次回顾:

![](../Images/678e7303331565fc5bcaa08400946132.png)

在之前的课程中，我们介绍了这些寄存器的基本功能，但是理解寄存器的 64 位至 8 位片非常重要。寄存器保存临时内存。这是这里的关键要点。

我们在基于 Linux 的汇编中有三个部分，包括:

**。数据=由数据定义组成**

**。bss =由可变数据分配组成**

**。text =实际代码**

在上面的例子中，我们使用了文本标签**，以免与**混淆。文本**部分。我们的编译器将获取我们所有的标签，确定一个实际的映射内存位置，并用实际二进制文件中的内存替换每个标签。**

 **重要的是要理解每个字符串字符都是一个字节长，由两个十六进制数字表示。有一个 ascii 表，你可以谷歌一下，它会显示所有这些值。每个十六进制数字是一个半字节或 4 位长。比如我们的' **H** 是 **0x48** ，' **e** 是 **0x65** 。让我们来看看十六进制编辑器中的二进制文件。

![](../Images/66abc5eac641a4ce7d57a04c8352a152.png)

在上周讲座的评论中，Aaron 指出了一个非常重要的问题，当您查看操作系统中的汇编与固件(如我们在之前的讲座中为操作系统创建的代码)时，您会明白这一点。

Aaron 在上周的评论中小心翼翼地指出，SYSCALL 完全依赖于操作系统。系统调用会因操作系统而异，因为每个操作系统都有不同的内核，并且每个操作系统都有自己的向量中断表，这些中断表都有一个 ID 和相应的数值。

SYSCALL 只不过是当二进制文件从相应的内核请求服务时，内核将接受参数或输入列表。在 x64 中，了解系统调用参数或输入对应于特定的寄存器是很重要的:

![](../Images/22e36dd1aa576216cd94200070bc0b46.png)

在传统的 linux 内核中有 328 个系统调用。正如我们在上面的代码中看到的，我们同时使用了 **SYS_WRITE** 和 **SYS_EXIT** 。让我们举例说明:

![](../Images/9dde4300e6c963fedbb05a1cca934125.png)

请花点时间看看上面的代码，看看这是如何工作的。在 **SYS_WRITE** 中，我们将 **1** 加载到 **RAX** 中，这是我们的系统调用。我们将 **1** 加载到 **RDI** 中，这是我们的第一个参数，代表我们的标准输出(0 =标准输入& 2 =标准误差)。我们的第二个参数被加载到 **RSI** 中，这是我们的**文本**标签，当被编译时，它将有一个实际的内存地址，就像你在调试器中看到的一样。最后，我们的第三个参数将保存字符串长度，在我们的例子中是 **13** ，并加载到 **RDX** 中。作为练习，我希望你写出 **SYS_EXIT** 如何做同样的事情，并且记住这里只有一个参数。在继续之前，请仔细阅读上面的代码，以牢固地理解这一点！

此外，我们有自己的 **_start** 标签，我们各自的操作系统会寻找这个标签，否则当它试图找到代码的入口点时就会抛出一个错误。**全局**声明告诉链接器数据的实际地址。

下周我们将在 GDB 调试二进制文件。**