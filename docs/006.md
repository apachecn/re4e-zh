# 第 4 部分:x86 汇编简介

> 原文:[https://0x infection . github . io/reversing/pages/part-4-x86-assembly-intro . html](https://0xinfection.github.io/reversing/pages/part-4-x86-assembly-intro.html)

如需所有课程的完整目录，请点击下方，因为除了课程涵盖的主题之外，它还会为您提供每个课程的简介。[https://github . com/mytechnotalent/逆向工程-教程](https://github.com/mytechnotalent/Reverse-Engineering-Tutorial)

女士们先生们，男孩女孩们，各个年龄段的孩子们！我们即将踏上一段将永远改变你生活的旅程！

要很好地理解汇编语言以及理解基础知识的重要性，需要涵盖大量的材料。

我们必须回答的第一个问题是什么是 x86 汇编语言，答案是向后兼容的汇编语言系列，它提供了对 Intel 8000 系列微处理器的兼容性。x86 汇编语言用于为上述系列的处理器产生目标代码。它使用助记符来表示 CPU 可以执行的指令。

x86 微处理器的汇编语言与各种操作系统协同工作。除了学习如何用 C 语言编程之外，我们还将关注使用 Intel 语法的 Linux 汇编语言，我们将反汇编源代码并分析各自的汇编。

x86 汇编语言有两种语法选择。自从美国电话电报公司·贝尔实验室开发出操作系统以来，美国电话电报公司语法在 Unix 世界中占主导地位。相比之下，Intel 语法最初用于 x86 平台的文档，在 MS-DOS 和 Windows 环境中占主导地位。

出于我们的目的，当我们最终反汇编或调试软件时，无论是在 Linux 还是 Windows 环境中，我们都会在很大程度上看到英特尔语法。无论我们检查的是 PE 格式的 Windows 二进制文件还是 ELF 格式的 Linux 二进制文件，这都是必不可少的。在本教程的后面会有更多的介绍。

两者的主要区别在于美国电话电报公司语法中，源在目的之前，而在英特尔语法中，目的在源之前。我们将在教程的后面更详细地讨论这一点。

在你跑出门后悔踏上这段旅程之前，请记住，一些基本的背景知识有助于我们在整个探索过程中发展。在这一点上，这些主题中的许多可能会令人困惑，这是完全正常的，因为我们将及时开发它们。

我们将把重点放在 Linux 汇编上，因为 Linux 可以在各种硬件上运行，并且能够运行手机、个人电脑或复杂的商业服务器等设备。

Linux 也是开源的，有很多版本。我们将在我们的演示中关注 Ubuntu，这些演示可以免费获得。相比之下，Windows 操作系统由一家公司拥有和控制，微软，所有的更新，安全补丁和服务补丁都直接来自他们，而 Linux 有数百万专业人员提供同样的绝对免费！

我们还将关注 32 位架构，因为最终大多数恶意软件都将为此而编写，以便感染尽可能多的系统。32 位应用程序/恶意软件将在 64 位系统上运行，因此我们希望了解 32 位世界的基础知识。

在下一课中，我们将讨论二进制数字系统。拿起你的咖啡，你会需要它的！